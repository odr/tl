{-# LANGUAGE DataKinds                 #-}
{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE FlexibleInstances         #-}
{-# LANGUAGE MagicHash                 #-}
{-# LANGUAGE MultiParamTypeClasses     #-}
{-# LANGUAGE ScopedTypeVariables       #-}
{-# LANGUAGE TypeFamilies              #-}
{-# LANGUAGE TypeOperators             #-}
-- {-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ConstraintKinds           #-}
{-# LANGUAGE FlexibleContexts          #-}
{-# LANGUAGE FunctionalDependencies    #-}
{-# LANGUAGE OverloadedStrings         #-}
{-# LANGUAGE PolyKinds                 #-}
module TL.Pers.DML where

import           Control.Monad.Catch     (MonadCatch)
import           Control.Monad.IO.Class  (MonadIO)
import           Control.Monad.Trans.RWS (RWS, get, put, runRWS, tell)
import           Data.Proxy              (Proxy (..))
import           Data.Text.Format        (Only (..), format)
import           Data.Text.Lazy          (Text)
import qualified Data.Text.Lazy          as TL
import           GHC.Exts                (Constraint)
import           GHC.Prim                (Proxy#, proxy#)
import           GHC.TypeLits            (KnownSymbol, Symbol, symbolVal')
import           Lens.Micro              ((^.))

import           TL.Pers.DDL
import           TL.Types

type family IsAutoPK  (rep:: *) back kr :: Constraint
type family IsAutoPKb (rep:: *) back kr :: Bool

class   ( TableLike a
        , Rep rep (RecordDef a) ar
        , Rep rep (Key a) kr
        , Rep rep (DataRecord a) dr
        )
        => DML (rep:: *) (back:: *) (a::DataDef *) (ar:: *) (kr:: *) (dr:: *)
            | rep a -> ar, rep a -> kr, rep a -> dr
  where
    -- | Insert the list of values into database.
    -- Should create Insert-statement with parameters
    -- and execute it for all values in list
    ins ::  ( MonadIO m
            , MonadCatch m
            )
            => Proxy '(rep,a) -> [ar]-> SessionMonad back m ()
    -- | In many cases PK should be generated.
    -- There are some possibilities:
    --
    -- * autogenerated PK (Sqlite, MSSQL)
    -- * generated from sequence (Oracle, PostgreSQL(?)) then inserted
    --
    -- In all cases interface is the same.
    -- If we need sequence name (Oracle) we can derive it from table name.
    --
    -- If for backend and table autogeneration of id's is impossible
    -- than empty key-list is returned
    insAuto ::  ( MonadIO m
                , MonadCatch m
                , IsAutoPK rep back kr
                )
                => Proxy '(rep,a) -> [dr] -> SessionMonad back m [kr]
    -- | Simple update by pk. Return list of pk which were updated
    upd ::  ( MonadIO m
            , MonadCatch m
            )
            => Proxy '(rep,a) -> [ar] -> SessionMonad back m [kr]
    -- | Delete values by condition.
    -- Count of deleted records is returned
    del ::  ( MonadIO m
            , MonadCatch m
            )
            => Proxy '(rep,a) -> Cond rep back (RecordDef a)
                -> SessionMonad back m Int
    selProj ::  ( MonadIO m
                , MonadCatch m
                , ContainNames (RecordDef a) b
                , Names b
                , RowRepDDL rep back (ProjNames (RecordDef a) b) rr
            )
            => Proxy '(rep,a,b) -> Cond rep back (RecordDef a)
            -> SessionMonad back m [rr]

-- | Select values by condition
sel :: forall rep (a :: DataDef *) back ar kr dr (m :: * -> *) rr.
    ( ContainNames (RecordDef a) (LFst (RecordDef a)), MonadCatch m
    , MonadIO m, Names (LFst (RecordDef a))
    , RowRepDDL rep back (ProjNames (RecordDef a) (LFst (RecordDef a))) rr
    , DML rep back a ar kr dr
    ) => Proxy '(rep, a) -> Cond rep back (RecordDef a)
        -> SessionMonad back m [rr]
sel (_::Proxy '(rep, a))
    = selProj (Proxy :: Proxy '(rep,a,LFst (RecordDef a)))

upsert :: forall rep (a :: DataDef *) ar back kr dr (m :: * -> *).
    ( Eq kr, MonadCatch m, MonadIO m
    , RecLens rep (RecordDef a) (Key a) ar kr
    , DML rep back a ar kr dr
    ) => Proxy '(rep, a) -> [ar] -> SessionMonad back m ()
upsert (p :: Proxy '(rep,a)) (xs::[ar]) = do
    res <- upd p xs
    ins p $ filter (\x -> (x ^. lensPk p) `notElem` res) xs

insRecCmd :: (KnownSymbol t, Names (LFst r), DBOption back)
    => Proxy '(rep,back,t,r) -> Text
insRecCmd (_ :: Proxy '(rep,back,t,r))
    = format "INSERT INTO {} ({}) VALUES({})"
        ( symbolVal' (proxy# :: Proxy# t)
        , TL.intercalate "," $ map TL.pack ns
        , TL.intercalate ","
            $ zipWith (const . paramName (proxy# :: Proxy# back)) [1..] ns
        )
  where
    ns = names (proxy# :: Proxy# (LFst r))

insRecCmdPars ::    ( KnownSymbol t
                    , RowRepDDL rep back r rr
                    , Names (LFst r)
                    , DBOption back
                    )
                    => Proxy '(rep,back,t,r) -> [rr] -> (Text, [[FieldDB back]])
insRecCmdPars (p::Proxy '(rep,back,t,r)) rs
    =   ( insRecCmd p
        , map (rowDb (proxy# :: Proxy# '(rep,back)) (Proxy::Proxy r)) rs
        )
type DataKey t = DataRecord t :++ Key t
updRecCmdPars
    :: (KnownSymbol (TabName t)
        , RecLens rep (RecordDef t) (Key t) s br
        , RecLens rep (RecordDef t) (DataKey t) s ar
        , Names (KeyDef t)
        , Names (LFst (DataKey t))
        , Names (LFst (DataRecord t))
        , RowRepDDL rep back (Key t) br
        , RowRepDDL rep back (DataKey t) ar
        , DBOption back
        , ContainNames (RecordDef t) (KeyDef t)
        , Single rep
        )
    => Proxy '(rep,back,t) -> [s] -> (Text, [[FieldDB back]])
updRecCmdPars (_ :: Proxy '(rep,back,t)) [] = mempty
updRecCmdPars (_ :: Proxy '(rep,back,t)) recs@(rc:_)
    =   ( format "UPDATE {} SET {} WHERE {}"
            ( symbolVal' (proxy# :: Proxy# (TabName t))
            , TL.intercalate ","
                $ zipWith (\n s ->
                        format "{} = {}" (s, paramName (proxy# :: Proxy# back) n)
                    ) [1..] ns
            , w
            )
        , map dataKey recs
        )
  where
    ns = names (proxy# :: Proxy# (LFst (DataRecord t)))
    (w,_,_) = runRWS (sqlWhere $ cond key) () (length ns + 1)
      where
        cond r = Equal (Proxy :: Proxy (KeyDef t)) r :: Cond rep back (RecordDef t)
        key = rc ^. recLens (proxy#::Proxy# '(rep,RecordDef t,Key t))
    dataKey r
        = rowDb (proxy# :: Proxy# '(rep,back))
                (Proxy :: Proxy (DataKey t))
                (r ^. recLens (proxy#::Proxy#  '( rep, RecordDef t, DataKey t ))
                )

data Cond (rep:: *) back (a :: [(Symbol,*)])
    = forall b br.  ( Names b
                    , RowRepDDL rep back (ProjNames a b) br
                    , ContainNames a b
                    )
                    => Equal (Proxy b) br
    | forall s b.   ( KnownSymbol s
                    , RowRepDDL rep back '[s:::b] (Singl rep b)
                    , Contains a '[s:::b]
                    )
                        => In (Proxy '(rep,back,s)) [b]
    | forall b br.  ( HasDef br ~ 'True
                    , Rep rep (ProjNames a b) br
                    , Names b
                    , ContainNames a b
                    )
                    => Null (Proxy b) -- | All fields in subrecord is null
    | forall b br.  ( HasDef br ~ 'True
                    , Rep rep (ProjNames a b) br
                    , Names b
                    , ContainNames a b
                    )
                    => NotNull (Proxy b) -- | All fields in subrecord is not null
    | forall b br.  ( Names b
                    , RowRepDDL rep back (ProjNames a b) br
                    , ContainNames a b
                    )
                    => Great (Proxy b) br
    | forall b br.  ( Names b
                    , RowRepDDL rep back (ProjNames a b) br
                    , ContainNames a b
                    )
                    => Least (Proxy b) br
    | And [Cond rep back a]
    | Or  [Cond rep back a]
    | Not (Cond rep back a)
    | CondTrue

instance Monoid (Cond rep back a) where
    mempty = CondTrue
    c1 `mappend` c2 = And [c1,c2]
    mconcat = And

sqlWhere :: (DBOption back, Single rep)
    => Cond rep back a -> RWS () [FieldDB back] Int Text
sqlWhere (x :: Cond rep back a) = case x of
    CondTrue        -> return "1=1"
    Equal pb b      -> rel pb b "="
    In (_ :: Proxy '(rep,back,s)) (bs :: [b]) ->
          format "{} IN ({})"
        . ((,) $ symbolVal' (proxy# :: Proxy# s))
        . TL.intercalate ", "
        <$> mapM (\b -> do
                num <- get
                tell $ rowDb (proxy# :: Proxy# '(rep,back))
                            (Proxy :: Proxy '[s:::b])
                            (single (proxy# :: Proxy# rep) b)
                put $ num + 1
                return $ paramName (proxy# :: Proxy# back) num
            ) bs
    Null pb    -> isNull pb ""
    NotNull pb -> isNull pb "NOT"
    Great pb b -> rel pb b ">"
    Least pb b -> rel pb b "<"
    And cs     -> ao cs " AND "
    Or cs      -> ao cs " OR "
    Not c      -> format "NOT ({})" . Only <$> sqlWhere c
  where
    rel :: (Names b, RowRepDDL rep back (ProjNames a b) br)
         => Proxy b -> br -> Text -> RWS () [FieldDB back] Int Text
    rel (_ :: Proxy b) vb op = do
        let bns = names (proxy# :: Proxy# b)
        num <- get
        tell $ rowDb (proxy# :: Proxy# '(rep,back))
                    (Proxy :: Proxy (ProjNames a b)) vb
        put $ num + length bns
        return
            $ TL.intercalate " AND "
            $ zipWith   (\n p ->
                    format "{} {} {}"
                            (n,op,paramName (proxy# :: Proxy# back) p)
                ) bns [num..]
    isNull (_ :: Proxy b) (t::Text) = return
        $ TL.intercalate " AND "
        $ map (\n -> format "{} IS {} NULL" (n,t))
        $ names (proxy# :: Proxy# b)
    ao cs t = TL.intercalate t . map (format "({})" . Only)
            <$> mapM sqlWhere cs

-- | Convert Condition to pair: "Where-text" and "list of query-parameters".
getSqlWhere ::  ( DBOption back
                , Single rep
                )
                => Cond rep back a -> (Text, [FieldDB back])
getSqlWhere c = let (r,_,w) = runRWS (sqlWhere c) () 1 in (r,w)

selRecCmdPars ::    ( KnownSymbol t
                    , Single rep
                    , Names a
                    , DBOption back
                    )
                    => Proxy '(rep,t,a)
                    -> Cond rep back r
                    -> (Text,[FieldDB back])
selRecCmdPars (_::Proxy '(rep,t,a)) c =
    ( format "SELECT {} FROM {} WHERE {}"
        ( TL.intercalate "," $ map TL.pack ns
        , symbolVal' (proxy# :: Proxy# t)
        , w
        )
    , ps
    )
  where
    (w,ps) = getSqlWhere c
    ns = names (proxy# :: Proxy# a)

delRecCmdPars :: (Single rep, KnownSymbol t, DBOption back)
    => Proxy# (t::Symbol) -> Cond rep back r -> (Text,[FieldDB back])
delRecCmdPars pt c =
    ( format "DELETE FROM {} WHERE {}" ( symbolVal' pt, w )
    , ps
    )
  where
    (w,ps) = getSqlWhere c
